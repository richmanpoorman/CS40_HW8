
.zero r0
.temps r6, r7

.section rodata
state:
        .space 1 
jumpTable:
        .space 256

.section init 
        m[r0][state] := r0 # Starts off in waiting mode
        r1 := r0
        
        
invalidReadSetLoop: # Do while loop to 255
        r5 := jumpTable + r1
        m[r0][r5] := invalidRead
        r1 := r1 + 1
        if (r1 != 256) goto invalidReadSetLoop using r4, r5
        m[r0][jumpTable + '\n'] := printValue
        m[r0][jumpTable + '+']  := add
        m[r0][jumpTable + '-']  := subtract
        m[r0][jumpTable + '*']  := multiply
        m[r0][jumpTable + '/']  := divide
        m[r0][jumpTable + '|']  := or
        m[r0][jumpTable + '&']  := and
        m[r0][jumpTable + 'c']  := changeSign
        m[r0][jumpTable + '~']  := complement
        m[r0][jumpTable + 's']  := swap
        m[r0][jumpTable + 'd']  := duplicate
        m[r0][jumpTable + 'p']  := popValue
        m[r0][jumpTable + 'z']  := clear
        m[r0][jumpTable + ' ']  := doNothing

        m[r0][jumpTable + '0']  := entering
        m[r0][jumpTable + '1']  := entering
        m[r0][jumpTable + '2']  := entering
        m[r0][jumpTable + '3']  := entering
        m[r0][jumpTable + '4']  := entering
        m[r0][jumpTable + '5']  := entering
        m[r0][jumpTable + '6']  := entering
        m[r0][jumpTable + '7']  := entering
        m[r0][jumpTable + '8']  := entering
        m[r0][jumpTable + '9']  := entering
        
        r4 := r0

.section text

# The different operations # 

# Name      : printValue
# Purpose   : Prints the entire stack out
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Will print out to the terminal; 
#             Needs the stack/value/result register to be correct
#             Assumes the jump table is set up
printValue:
        push r1 on stack r2     # Saves the return location
        goto enterWaiting linking r1

        r5 := r3
loopStackValues:
        if (r5 == valueStack) goto finishPrintValue using r1
        # output "Looping\n"
        r1 := m[r0][r5]
        # output "Got the r1 value\n"

        output ">>> "

        # output "Calling printDigit\n"
        push r5 on stack r2 
        push r1 on stack r2 
        goto printDigit linking r1
        pop stack r2
        pop r5 off stack r2

        output '\n'
        
        r5 := r5 + 1
        
        goto loopStackValues
finishPrintValue:
        
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : add
# Purpose   : Adds the top 2 values of the stack 
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack
add:
        push r1 on stack r2     # Saves the return location
        goto enterWaiting linking r1
        
        # Check_stack
        push r4 on stack r2
        if(r3 >s valueStack - 2) goto print_underflow_2 using r4,r5
        
        pop r1 off stack r3 # Get the top value of the stack 
        # r1 := r1 + '0'
        # output r1
        # output "that was number"
        pop r5 off stack r3 # Get the second top value of the stack
        r5 := r5 + r1 # add them together 
        push r5 on stack r3 # Push the added value onto the stack

        pop r4 off stack r2
        pop r5 off stack r2     # Gets back the return location 
        r1 := 0
        goto r5 

# Name      : print_underflow_1 
# Purpose   : operations that pop two on stack but the stack < 2
# Parameters: none 
# Return    : None 
# Notes     : print out message then go back to call
print_underflow_1:
        pop r4 off stack r2
        output "Stack underflow---expected at least 1 element"
        output "\n"
        pop r5 off stack r2     # Gets back the return location 
        r1 := 0
        goto r5 

# Name      : print_underflow_2 
# Purpose   : operations that pop two on stack but the stack < 2
# Parameters: none 
# Return    : None 
# Notes     : print out message then go back to call
print_underflow_2:
        pop r4 off stack r2
        output "Stack underflow---expected at least 2 elements"
        output "\n"
        pop r5 off stack r2     # Gets back the return location 
        r1 := 0
        goto r5 






# Name      : subtract
# Purpose   : Subtracts the second from the top by the top value in the stack
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack
subtract:
        push r1 on stack r2     # Saves the return location
        
        goto enterWaiting linking r1
        # Check_stack
        push r4 on stack r2
        if(r3 >s valueStack - 2) goto print_underflow_2 using r4,r5

        pop r1 off stack r3 # Get the top value of the stack 
        pop r5 off stack r3 # Get the second top value of the stack

        r5 := r5 - r1 # subtracts them  
        push r5 on stack r3 # Push the subtracted value onto the stack
        pop r4 off stack r2
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : multiply
# Purpose   : Multiplies the top two values of the stack
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack
multiply:
        push r1 on stack r2     # Saves the return location
        goto enterWaiting linking r1
        
        # Check_stack
        push r4 on stack r2
        if(r3 >s valueStack - 2) goto print_underflow_2 using r4,r5

        pop r1 off stack r3 # Get the top value of the stack 
        pop r5 off stack r3 # Get the second top value of the stack

        r5 := r5 * r1 # multiplies them  
        push r5 on stack r3 # Push the multiplied value onto the stack
        pop r4 off stack r2
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : divide
# Purpose   : Divides the second from the top value by the top value; if 
#             the top value is 0, then it prints an error message 
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack
divide:
        push r1 on stack r2     # Saves the return location
        
        goto enterWaiting linking r1
        # Check_stack
        push r4 on stack r2 
        if(r3 >s valueStack - 2) goto print_underflow_2 using r4,r5
        pop r4 off stack r2
        if (m[r0][r3] != r0) goto divideNoError using r1

        output "Division by zero\n"
        
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 
divideNoError: 
        # Check_stack
        r5 := r3 + 1
        pop r1 off stack r3 # Get the top value of the stack 
        pop r5 off stack r3 # Get the second top value of the stack

        r5 := r5 / r1 # divides them  
        push r5 on stack r3 # Push the divided value onto the stack
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : or
# Purpose   : Bitwise or the top two values of the stack
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack
or:
        push r1 on stack r2     # Saves the return location
        
        goto enterWaiting linking r1
        push r4 on stack r2
        if(r3 >s valueStack - 2) goto print_underflow_2 using r4,r5
        pop r4 off stack r2
        pop r1 off stack r3 # Get the top value of the stack 
        pop r5 off stack r3 # Get the second top value of the stack

        r5 := r5 | r1 # or them  
        push r5 on stack r3 # Push the bitwise or value onto the stack

        
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : and
# Purpose   : Bitwise and the top two values of the stack
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack
and:
        push r1 on stack r2     # Saves the return location
        
        goto enterWaiting linking r1
        push r4 on stack r2
        if(r3 >s valueStack - 2) goto print_underflow_2 using r4,r5
        pop r4 off stack r2
        pop r1 off stack r3 # Get the top value of the stack 
        pop r5 off stack r3 # Get the second top value of the stack

        r5 := r5 & r1 # and them  
        push r5 on stack r3 # Push the bitwise and value onto the stack

        
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : changeSign
# Purpose   : Changes the sign of the top value of the stack
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack
changeSign:
        push r1 on stack r2     # Saves the return location
        
        goto enterWaiting linking r1
        # Check_stack
        push r4 on stack r2
        if(r3 >s valueStack - 1) goto print_underflow_1 using r4,r5
        pop r4 off stack r2
        pop r5 off stack r3 # Get the top value of the stack 
        r5 := r0 - r5 # do 0 - r5 to flip the sign  
        push r5 on stack r3 # Push the changed sign onto the stack

        
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : complement
# Purpose   : Does bitwise complement of the top value of the stack
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack
complement:
        push r1 on stack r2     # Saves the return location
        
        goto enterWaiting linking r1
        # Check_stack
        push r4 on stack r2
        if(r3 >s valueStack - 1) goto print_underflow_1 using r4,r5
        pop r4 off stack r2
        pop r5 off stack r3 # Get the top value of the stack
        r5 := ~r5 # multiplies them  
        push r5 on stack r3 # Push the complemented value onto the stack

       
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : swap
# Purpose   : Swaps the top two values on the value stack
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack
swap:
        push r1 on stack r2     # Saves the return location
        
        goto enterWaiting linking r1
        push r4 on stack r2
        if(r3 >s valueStack - 2) goto print_underflow_2 using r4,r5
        pop r4 off stack r2
        pop r1 off stack r3 # Get the top value of the stack 
        pop r5 off stack r3 # Get the second top value of the stack

        # Push them on to reverse order
        push r1 on stack r3 
        push r5 on stack r3 
        
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : duplicate
# Purpose   : Pushes a copy of the top onto the stack
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack
duplicate:
        push r1 on stack r2     # Saves the return location
        
        goto enterWaiting linking r1
        push r4 on stack r2
        if(r3 >s valueStack - 1) goto print_underflow_1 using r4,r5
        pop r4 off stack r2
        r5 := r3
        push m[r0][r5] on stack r3 # Pushes the top value of the stack

        
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : pop
# Purpose   : Removes the top value of the stack
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack
popValue:
        push r1 on stack r2     # Saves the return location
        
        goto enterWaiting linking r1
        push r4 on stack r2
        if(r3 >s valueStack - 1) goto print_underflow_1 using r4,r5
        pop r4 off stack r2
        pop stack r3 # Pops the top value off

        
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : clear
# Purpose   : Clears the value stack
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack
clear:
        push r1 on stack r2     # Saves the return location
        
        goto enterWaiting linking r1
        r3 := valueStack

        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : doNothing
# Purpose   : Does nothing (except exit entering mode)
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Only changes state
doNothing:
        push r1 on stack r2     # Saves the return location
        
        goto enterWaiting linking r1
        
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 


# Name      : entering
# Purpose   : Recieves the inputed number (into r4)
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Adjusts the value stack;
#             Adjusts the r4 value
entering:
        push r1 on stack r2     # Saves the return location
        
        goto enterEntering linking r1
        
        # Gets the character as a number
        r5 := r2 + 1
        r5 := m[r0][r5]
        r5 := r5 - '0'

        # Adds the number to the running total

        r4 := r4 * 10
        r4 := r4 + r5
        
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : invalidRead
# Purpose   : Prints out an invalid read message
# Parameters: The value of the character read 
# Return    : None 
# Notes     : Only called when other characters are bad
invalidRead:
        push r1 on stack r2     # Saves the return location
        
        goto enterWaiting linking r1

        output "Unknown character \'"
        output m[r0][r2 + 1]
        output "\'\n" 

        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# HELPER FUNCTIONS #

# Name      : enterWaiting
# Purpose   : Changes state to waiting (if possible)
# Parameters: None
# Return    : None 
# Notes     : Changes state
enterWaiting:
        push r1 on stack r2     # Saves the return location

        # If already in waiting state, do nothing
        if (m[r0][state] == r0) goto exitWaitingFunction using r1

        # Otherwise, go to the waiting state
        push r4 on stack r3
        r4 := r0

        m[r0][state] := r0
        
exitWaitingFunction:
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 

# Name      : enterEntering
# Purpose   : Changes state to entering (if possible)
# Parameters: None
# Return    : None 
# Notes     : Changes state
enterEntering:
        push r1 on stack r2     # Saves the return location
        
        if (m[r0][state] == 1) goto exitEnteringFunction using r1, r5

        r4 := r0
        m[r0][state] := 1

exitEnteringFunction:
        pop r5 off stack r2     # Gets back the return location 

        r1 := 0
        goto r5 
